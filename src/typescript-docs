Primitive type: string, number, boolean
배열:
    [1, 2, 3] => number[] or Array<number>

any: 타입 검사 오류 발생 안함. 타입스크립트를 안심시킨다고 볼 수 있음.

변수에 대한 타입 표기: 선택사항으로 생략해도 무방함. (변수의 초깃값을 바탕으로 추론)
    - let myName: string = "Alice" === let myName = "Alcie"

함수:
    매개변수의 타입, 반환값의 타입 표기 가능
    ex) 
        function getFavoriteNumber(x: number): number {
            return x;
        }
    ---> 위 예제의 경우에도 반환 타입은 표기하지 않아도 무방 (자동 추론)
객체 타입:
    , 혹은 ; 로 구분 가능
    ex) 
        function printCoord(pt: { x: number; y: number }) { ~~~ }
    이때, 보통 object literal type의 경우(위 코드의 pt: { x: number; y: number } 부분)는 따로 interface나 type으로 빼줘서 선언 후 사용

옵셔널 프로퍼티: ?: 로 사용가능 -> undefined 반환

유니언 타입: | 로 여러개 타입 사용 가능
    ex) 
        function printId(id: number | string) { ~~~ }
    단, 유니언을 다룰 때는 해당 유니언 타입의 모든 멤버에 대하여 유효한 작업일 때에만 허용
    ex) 
        function printId(id: number | string) {
            console.log(id.toUpperCase()); ==> 에러 발생 (string 타입에만 유효한 메소드이기 때문)
        ---> 이러하게 사용하고 싶을 경우 typeof 등으로 분기를 시켜서 사용해야함

타입 별칭:
    type Point = {
        x: number;
        y: number;
    }
인터페이스:
    interface Point {
        x: number;
        y: number;
    }

타입 vs 인터페이스:
    - 대부분 동일 but 타입은 생성된 뒤 달라질 수 없지만 인터페이스는 병합 확장 가능
        1) 확장 예제
        ex) 
            interface Animal {
                name: string
            }
            interface Bear extends Animal {
                honey: boolean
            }
            -----------
            type Animal = {
             name: string
            }
            type Bear = Animal & {
                honey: boolean
            }
        2) 병합 확장 예제
        ex)
            interface Window {
                title: string
            }
            interface Window {
                title2: string
            }
        ----> 타입을 이와 같이 사용할 경우는 에러 발생
    - 인터페이스는 객체의 모양을 선언하는 데만 사용. 즉 원시 타입 별칭 부여는 type만 가능
    - 공식 문서에서는 개인적 선호에 따라 둘중 하나를 선택해서 사용할 수 있지만 잘 모르겠을 경우에는 interface를 사용해보고 문제가 발생했을 때 type을 사용하라고 나와있음.

읽기 전용 프로퍼티:
    객체가 처음 생성될 때만 수정 가능
    ex) 
        interface Point {
            readonly x: number;
            readonly y: number;
        }
        let p1: Point = {x: 10, y: 20};
        p1.x = 5; // 오류 발생
    잠깐, const랑 readonly의 차이는? 변수는 const를 사용하고 프로퍼티는 readonly 사용

리터럴 타입:
    구체적인 문자나 숫자를 타입으로 지정
    ex) 유용한 사용 예제
        function printText (str: string, alignment: "left" | "right" | "center") { ~~~ }

리터럴 추론:
    객체 사용하여 변수 초기화할 경우 객체 프로퍼티는 이후에 값이 변화할 수 있다고 가정
    ex) 
        const req = { url: "https://example.com", method: "GET"};
        handleRequest(req.url, req.method); (handleRequest는 url: string, method: "GET" | "POST")로 선언되었음
        ==> string 타입은 "GET" | "POST"의 타입으로 할당될 수 없다고 나옴. 왜? method는 값이 변할 수 있는 string 타입으로 되었다고 판단
    
    ==> 해결책
        ex) 타입단언(assertion) 추가
            const req = { url: "https://example.com", method: "GET" as "GET" (타입을 단언해줌) };
        ex) as const 사용하여 객체 전체를 리터럴 타입으로 변환
            const req = { url: "https://example.com", method: "GET" } as const;

Null 아님 단언 연산자: !. 을 사용하여 타입 단언 -> null 또는 undefined 아닐때만 사용해야함.
    ex) console.log(x!.toFixed());

제네릭:
    ex) 
        function identity<T>(arg: T): T {
            return arg;
        }
    ==> 사용 시 유저가 주는 타입으로 함수 내에서 사용된다.
        let output = identity<string>("myString"); // 출력 타입은 'string'입니다.
        let output = identity("myString"); //출력 타입은 'string'입니다. ===> Generic도 타입 인수를 추론한다.
