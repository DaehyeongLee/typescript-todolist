- 타입스크립트 사용의 목적은?
  TypeScript 쓰면, 버그가 싹 다 사라진다. -> x
  TypeScript 쓰면, Test 작성 안해도 된다. -> x
  --> ypeScript 로 타이핑을 잘하면, 런타임 전에 미리 알 수 있는 오류도 있다.

- 타입스크립트의 타입 시스템
  1) 컴파일러에게 사용하는 타입을 명시적으로 알려줌 --> 명시적으로 타입 지정 가능
  2) 컴파일러가 자동으로 타입을 추론 --> 명시적으로 지정 안할 경우 자동으로 타입 추론
  이때, 추론을 할 경우 any타입으로 지정되는 경우가 있는데 이를 방지할 수 있다. "noImplicitAny" : true ---> 명시적으로 타입 지정하도록 유도

- noImplicitAny, strictNullChecks, noImplicitReturns
  1) noImplicitAny 킬 경우 명시적으로 타입 지정해줘야함
  2) strictNullChecks 킬 경우 모든 타입에 자동으로 포함되는 null, undefined 가 포함되지 않음
  3) noImplicitReturns 킬 경우 함수 내에서 모든 코드가 값을 리턴하지 않으면, 컴파일 에러를 발생시킴

- Function 사용법
  1) type:
    type EatType = (food: string) => void;
  2) interface:
    interface IEatType {
      (food: string): void;
    }
- Array 사용법
  1) type:
    type PersonList = string[];
  2) interface:
    interface IPersonList {
      [index: number]: string;
    }

- 서브 타입
  1) let sub1: 1 = 1;
     let sup1: number = sub1; // 좁은 타입에서 넓은 타입으로의 대입은 가능 (리터럴 1은 number의 서브타입)
     sub1 = sup1; // sup1은 number, sub1은 리터럴(1) 이므로 넓은 타입에서 좁은 타입으로의 대입인 상황 -? 에러
  2) let sub2: number[] = [1];
     let sup2: object = sub2; // 배열은 object에 포함이므로 가능 (배열은 object의 서브타입)
     sub2 = sup2; // 에러
  3) let sub3: [number, number] = [1, 2];
     let sup3: number[] = sub3; // 튜플은 배열의 포함 (튜플은 배열의 서브타입)
     sub3 = sup3; // 에러
  4) let sub4: { a: string, b: number} = { a: "a", b: 1}
     let sup4: { a: string | number, b: number} = sub4
     ===> Object의 경우 각각의 프로퍼티가 대응하는 프로퍼티가 같거나 서브타입이어야 대입 가능, Array도 마찬가지.

- any와 unknown
  unknown은 무조건 타입을 좁혀서 사용해야 하는 의무가 있는 반면,
  any는 타입을 좁혀서 사용하지 않아도 되서 자유롭다는 차이점이 있다.

  1) any
    function func(a: any): number | string | void {
      a.toString(); // any 타입이므로 문제가 발생하지는 않는다.

      if (typeof a === 'number') {
        return a * 10;
      } else if (typeof a === 'string') {
        return `Hello ${a}`
      }
    }
  2) unknown
    function funcUnknown(a: unknown): number | string | void {
      a.toString(); // unknown 타입이므로 문제가 발생.

      // 아래 코드에 대해서는 문제 발생 안함 --> any 대신 unknown을 사용할 경우 안정성 높일 수 있음.
      if (typeof a === 'number') {
        return a * 10;
      } else if (typeof a === 'string') {
        return `Hello ${a}`
      }

- 타입 추론
  let 과 const 의 타입 추론 차이
    1) let a = 'Mark' // string
       const b = 'Mark' // 'Mark' => literal type
    2) let c = 38 // number
       const d = 38 // 38 => literal type
    3) let g = ['Mark', 'Pen'] // string[]
       const h = ['Mark', 'Pen'] // string[]
       const i = ['Mark', 'Pen'] as const // readonly ['Mark', 'Pen']
  Best Common type
    1) let j = [0, 1, null] // (number | null) []
    2) const j = [0, 1, null] // (number | null) []
  Contextual Typing - 위치에 따라 추론이 다름
    1) const click = (e) => {
      e; // any
    }
    2) document.addEventListener('click', (e) => {
      e; //MouseEvent
    })

- Type Guard로 안전함을 파악하기! (중요)